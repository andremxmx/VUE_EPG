import type { Ref } from 'vue';
import type { MaybeComputedRef } from '@vueuse/core';
import type { Channel, Program, Theme } from '../helpers/interfaces';
import type { BaseTimeFormat, ChannelWithPosiiton, DateTime, Position, ProgramItem } from '../helpers/types';
interface useEpgProps {
    channels: MaybeComputedRef<Channel[]>;
    epg: MaybeComputedRef<Program[]>;
    width?: number;
    height?: number;
    startDate?: MaybeComputedRef<DateTime>;
    endDate?: MaybeComputedRef<DateTime>;
    isBaseTimeFormat?: Ref<BaseTimeFormat>;
    isSidebar?: Ref<boolean>;
    isTimeline?: Ref<boolean>;
    isLine?: boolean;
    theme?: MaybeComputedRef<Theme>;
    dayWidth?: Ref<number>;
    sidebarWidth?: Ref<number>;
    itemHeight?: Ref<number>;
    itemOverscan?: number;
}
export declare function useEpg({ channels: channelsEpg, epg, startDate: startDateInput, endDate: endDateInput, isBaseTimeFormat, isSidebar, isTimeline, isLine, theme: customTheme, dayWidth: customDayWidth, sidebarWidth, itemHeight, itemOverscan, width, height, }: useEpgProps): {
    getEpgProps: () => {
        width?: number | undefined;
        height?: number | undefined;
        isSidebar: boolean;
        isTimeline?: boolean | undefined;
        isLoading?: boolean | undefined;
        loader?: string | undefined;
        theme: Theme;
        sidebarWidth: number;
        setContainerRef: (ref: any) => void;
    };
    getLayoutProps: () => {
        programs: ProgramItem[];
        channels: ChannelWithPosiiton[];
        startDate: DateTime;
        endDate: DateTime;
        scrollY: number;
        dayWidth: number;
        hourWidth: number;
        numberOfHoursInDay: number;
        offsetStartHoursRange: number;
        sidebarWidth: number;
        itemHeight: number;
        onScroll: (e: any) => void;
        isBaseTimeFormat?: boolean | undefined;
        isSidebar?: boolean | undefined;
        isTimeline?: boolean | undefined;
        isLine?: boolean | undefined;
        isProgramVisible: (position: Position) => boolean;
        isChannelVisible: (position: Pick<Position, 'top'>) => boolean;
        setScrollBoxRef: (el: HTMLDivElement) => void;
    };
    onScrollToNow: () => void;
    onScrollTop: (value?: number) => void;
    onScrollLeft: (value?: number) => void;
    onScrollRight: (value?: number) => void;
    scrollY: Ref<number>;
    scrollX: Ref<number>;
};
export {};
